# 2020牛客暑期多校训练营（第九场）

## A.Groundhog and 2-Power Representation

幂次式计算。py模拟。  
听说还有函数。

```python
s = input()
n = len(s)

def cal(l, r):
    # print(l, r)
    sum = 0
    sum = int(sum)
    i = l;
    while i <= r :
        # print(i)
        if s[i] == '2':
            if i+1 <= r and s[i+1] == '(':
                cnt = 0
                j = i+1
                while j <= r:
                    # print(j)
                    if s[j] == '(':
                        cnt = cnt + 1
                    if s[j] == ')':
                        cnt = cnt - 1
                        if cnt == 0:
                            break
                    j = j + 1
                sum = sum + 2 ** cal(i+2, j-1)
                i = j+1
            else:
                sum = sum + 2
        i = i+1
    return sum
            

# cal(0)
print(cal(0, n-1))

```

## B
## C
## D
## E.Groundhog Chasing Death

求$\prod _{i=a}^b \prod _{j=c}^d gcd(x^i, y^j)$,根据$gcd$的性质有$gcd(i/m, j/m) = gcd(i, j)*m$我们单独对$x, y$共有的质因子计算，$x = p^l, y = p^r, gcd(x, y) = p^{min(l, r)}$,所以这题转化成对$x, y$共有的质因子$p_i$计算$\prod_{x=1}^k \prod_{i=a}^b \prod_{j=c}^d p_x^{min(c1*i, c2*j)}$, $c1, c2$分别是两者的质因子个数。对于每个$p$的幂次，只用计算两者较小的，但是可能会有相等的情况，所以规定相等的情况只在计算$y$的时候计算就可以避免重复了。写的居然忘记欧拉函数是个什么了。。所以幂次计算当幂次大于$1e14$的时候计算一次，然后就卡过去了。

```c++
#include<iostream>
#include<string>
#include<cstdio>
#include<vector>
#include<string.h>
#include<cstring>
#include<set>
#include<queue>
#include<algorithm>
#include<math.h>
#include<stdio.h>
#include<map>
#include<stack>
#include<list>
#define pii pair<int, int>
#define pll pair<LL, LL>
#define pil pair<int, LL>
#define pli pair<LL, int>
#define mp make_pair
#define pb push_back
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define MINF 0x3f3f3f3f
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;
const LL LLINF = 1e18;
const int INF = 1e9;
const int MOD = 998244353;
const int HMOD = 999959;
const int VMOD = 5000000;
const int MAXN = 3e5+10;
const int MAXM = 5e5+10;
const int INV = 10050505;
const LL LLINV = 1e18;
const double eps = 1e-3;
int dirx[5] = {0, -1, 1, 0, 0}, diry[5] = {0, 0, 0, -1, 1};
  
int a, b, c, d, x, y;
vector<pii> px, py;
vector<pair<int, pii>> p;
  
LL powmod(LL a, LL b)
{
    LL ans = 1;
    while(b)
    {
        if (b&1) ans = ans*a%MOD;
        a = a*a%MOD;
        b >>= 1;
    }
    return ans;
}
  
void check()
{
    LL ans = 1;
    for (int i = a;i <= b; ++i)
    {
        for (int j = c;j <= d; ++j)
        {
            ans = ans*(LL)__gcd(powmod(x, i), powmod(y, j))%MOD;
        }
    }
    cout << "check: " << ans << endl;
}
  
int main()
{
IOS;
#ifdef LOCAL_JUDGE
    freopen("test.in", "r", stdin);
    // freopen("test.out", "w", stdout);
#endif
    scanf("%d%d%d%d%d%d", &a, &b, &c, &d, &x, &y);
    // check();
    for (int i = 2;i*i <= x; ++i)
    {
        if (x%i == 0)
        {
            int cnt = 0;
            while(x%i == 0)
            {
                ++cnt;
                x /= i;
            }
            px.pb(mp(i, cnt));
        }
    }
    if (x > 1) px.pb(mp(x, 1));
    for (int i = 2;i*i <= y; ++i)
    {
        if (y%i == 0)
        {
            int cnt = 0;
            while(y%i == 0)
            {
                ++cnt;
                y /= i;
            }
            py.pb(mp(i, cnt));
        }
    }
    if (y > 1) py.pb(mp(y, 1));
  
    int l = 0, r = 0;
    while (l < (int)px.size() && r < (int)py.size())
    {
        if (px[l].first == py[r].first)
        {
            p.pb(mp(px[l].first, mp(px[l].second, py[r].second)));
            ++l;
            ++r;
        }
        else
        {
            if (px[l].first < py[r].first) ++l;
            else ++r;
        }
    }
    LL ans = 1;
    for (auto pi: p)
    {
        LL c1 = pi.second.first, c2 = pi.second.second;
        // cout << pi.first << ' ' << c1 << ' ' << c2 << endl;
        LL sum = 0;
        for (int i = a;i <= b; ++i)
        {
            LL v = (c1*i)/c2+1;
            sum += max(0LL, d-max(v, (LL)c)+1)*i*c1;
            // cout << i << ' ' << max(0LL, d-max(v, (LL)c)+1)*i%MOD*c1%MOD << endl;
            if (sum > 1e14)
            {
                ans = (ans * powmod(pi.first, sum))%MOD;
                sum = 0;
            }
        }
 
        // cout << sum << endl;
        for (int i = c;i <= d; ++i)
        {
            LL v = (c2*i+c1-1)/c1;
            sum += max(0LL, b-max(v, (LL)a)+1)*i*c2;
            if (sum > 1e14)
            {
                ans = (ans * powmod(pi.first, sum))%MOD;
                sum = 0;
            }
            // cout << i << ' ' << max(0LL, b-max(v, (LL)a)+1)*i%MOD*c2%MOD << endl;
        }
        ans = (ans * powmod(pi.first, sum))%MOD;
        // cout << sum << endl;
        // cout << sum << endl;
        // ans = (ans * powmod(pi.first, sum))%MOD;
    }
    printf("%lld\n", ans);
  
    return 0;
}
```

## F.Groundhog Looking Dowdy

有$n$天， 每一天有$k_i$件衣服给你选，衣服有值，选$m$天穿一件衣服出去，让衣服的值差值最小。  
按值排序，双指针跑一遍，居然这么sb的题都不会了。。。

```c++
#include<iostream>
#include<string>
#include<cstdio>
#include<vector>
#include<string.h>
#include<cstring>
#include<set>
#include<queue>
#include<algorithm>
#include<math.h>
#include<stdio.h>
#include<map>
#include<stack>
#include<list>
#define pii pair<int, int>
#define pll pair<LL, LL>
#define pil pair<int, LL>
#define pli pair<LL, int>
#define mp make_pair
#define pb push_back
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define MINF 0x3f3f3f3f
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;
const LL LLINF = 1e18;
const int INF = 1e9;
const int MOD = 20101009;
const int HMOD = 999959;
const int VMOD = 5000000;
const int MAXN = 1e6+10;
const int MAXM = 5e5+10;
const int INV = 10050505;
const LL LLINV = 1e18;
const double eps = 1e-3;
int dirx[5] = {0, -1, 1, 0, 0}, diry[5] = {0, 0, 0, -1, 1};

int n, m, tot;
pii v[MAXN*2];
int cnt[MAXN];

int main()
{
IOS;
#ifdef LOCAL_JUDGE
	freopen("test.in", "r", stdin);
	// freopen("test.out", "w", stdout);
#endif
	scanf("%d%d", &n, &m);
	tot = 0;
	for (int i = 1;i <= n; ++i)
	{
		int k, x;
		scanf("%d", &k);
		while (k--)
		{
			scanf("%d", &x);
			v[++tot] = mp(x, i);
		}
	}
	sort(v+1, v+1+tot);
	int ans = 1e9;
	int l = 1, r = 0;
	int sum = 0;
	while(l <= tot)
	{
		while(sum < m && r < tot)
		{
			++r;
			++cnt[v[r].second];
			if (cnt[v[r].second] == 1) ++sum;
		}
		if (sum == m) ans = min(ans, v[r].first-v[l].first);
		--cnt[v[l].second];
		if (cnt[v[l].second] == 0) --sum;
		++l;
	}
	printf("%d\n", ans);

	return 0;
}
```

## G.Groundhog Playing Scissors
## H.Groundhog Speaking Groundhogish
## I.The Crime-solving Plan of Groundhog
## J.The Escape Plan of Groundhog
## K.The Flee Plan of Groundhog

一颗树， 从$1$到$n$的路径上跑$t$步之后，$n$点有个怪物以两倍的速度追你，问你最长能活多久，追上就死，你一步怪物一步。  
令$d[u]$,表示$1$为根的情况到$u$点的步数，当$t$大于$d[u]-d[1]$时，跑都跑不了。  
其他情况可以预处理能跑的最远距离$d[n]-d[1]-t$， 然后枚举每个点计算抓到的时间， 对于时间较比最长还长就不计算，其他情况取个最大即可。  

```c++
#include<iostream>
#include<string>
#include<cstdio>
#include<vector>
#include<string.h>
#include<cstring>
#include<set>
#include<queue>
#include<algorithm>
#include<math.h>
#include<stdio.h>
#include<map>
#include<stack>
#include<list>
#define pii pair<int, int>
#define pll pair<LL, LL>
#define pil pair<int, LL>
#define pli pair<LL, int>
#define mp make_pair
#define pb push_back
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define MINF 0x3f3f3f3f
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;
const LL LLINF = 1e18;
const int INF = 1e9;
const int MOD = 20101009;
const int HMOD = 999959;
const int VMOD = 5000000;
const int MAXN = 1e5+10;
const int MAXM = 5e5+10;
const int INV = 10050505;
const LL LLINV = 1e18;
const double eps = 1e-3;
int dirx[5] = {0, -1, 1, 0, 0}, diry[5] = {0, 0, 0, -1, 1};

struct Edge
{
	int v, nxt;
}e[MAXN*2];
int n, t, cnt, s;
int d[MAXN], fir[MAXN], f[MAXN][20];

void addedge(int u, int v)
{
	e[cnt] = Edge{v, fir[u]};
	fir[u] = cnt;
	++cnt;
}

void dfs(int u, int fa)
{
	d[u] = d[fa] + 1;
	f[u][0] = fa;
	for (int i = 1;i < 20; ++i)
	{
		if ((1<<i) > d[u]) break;
		f[u][i] = f[f[u][i-1]][i-1];
	}
	for (int i = fir[u];~i; i = e[i].nxt)
	{
		int v = e[i].v;
		if (v == fa) continue;
		dfs(v, u);
	}
}

int lca(int x, int y)
{
	if (d[x] < d[y]) swap(x, y);
	for (int i = 19;i >= 0; --i)
		if ((1<<i) <= d[x]-d[y]) x = f[x][i];
	if (x == y) return x;
	for (int i = 19;i >= 0; --i)
		if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];
	return f[x][0];
}

bool getp(int u, int fa)
{
	if (u == n) return true;
	bool ok = false;
	for (int i = fir[u];~i;i = e[i].nxt)
	{
		int v = e[i].v;
		if (v == fa) continue;
		ok = getp(v, u);
		if (ok)
		{
			if (d[u]-1 == t) s = u;
			return true;
		}
	}
	return false;
}

int main()
{
IOS;
#ifdef LOCAL_JUDGE
	freopen("test.in", "r", stdin);
	// freopen("test.out", "w", stdout);
#endif
	scanf("%d%d", &n, &t);
	memset(fir, -1, sizeof(fir));
	for (int i = 1, u, v;i < n; ++i)
	{
		scanf("%d%d", &u, &v);
		addedge(u, v);
		addedge(v, u);
	}
	dfs(1, 0);
	if (t >= d[n])
	{
		puts("0");
		return 0;
	}
	getp(1, 0);
	int ans = 0, maxt = (d[n]-1-t);
	// cout << d[4] << endl;
	for (int i = 1;i <= n; ++i)
	{
		// cout << i << endl;
		int len1 = d[s]+d[i]-d[lca(s, i)]*2;
		int len2 = d[n]+d[i]-d[lca(i, n)]*2;
		// cout << d[n] << ' ' << d[i] << ' ' << lca(s, n) << ' '
		int t1 = len1, t2 = (len2+1)/2;
		if (t1 > t2) continue;
		if (t2 > maxt) continue;
		ans = max(ans, t2);
	}
	printf("%d\n", ans);

	return 0;
}
```

## L.The Shopping Plan of Groundhog